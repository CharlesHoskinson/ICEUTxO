# 8. Related Work

ICE-UTxO sits at the intersection of multiparty session types, UTxO-based blockchain models, sharded consensus, and mechanized verification of concurrent systems. We organise the related literature along these four axes, devoting the most space to session-type theory, which is closest to our contribution.

---

## 8.1 Multiparty Session Types

### Foundational Theory

The multiparty session type (MPST) discipline originates with Honda, Yoshida, and Carbone [Honda et al., 2016], who introduced *global types* as choreographic specifications from which local endpoint types are obtained by *projection*. Their framework guarantees communication safety, session fidelity, and progress for asynchronous sessions with arbitrarily many participants. ICE-UTxO adopts the global-type/projection architecture wholesale but departs in two critical ways: (i) our global types are indexed by *UTxO references* rather than channel names, so that each protocol step is anchored to an on-chain datum; and (ii) projection targets *transaction validator scripts* rather than process calculi, yielding proof obligations that are discharged at ledger-submission time rather than at compile time.

Bejleri, Denielou, and Yoshida [Bejleri et al., 2019] provide a comprehensive survey of the MPST landscape, classifying systems by their type discipline, communication medium, and verification strategy. In the taxonomy they propose, ICE-UTxO occupies a novel cell: it is an *asynchronous, event-structure-based* system whose communication medium is a *shared ledger* rather than point-to-point channels or shared memory. Our work thus extends the MPST design space along a dimension that the survey identifies as open.

### Interleaving and Global Progress

Bettini, Coppo, D'Antoni, De Luca, Dezani-Ciancaglini, and Yoshida [Bettini et al., 2008] study *global progress* for multiparty sessions that are dynamically interleaved on shared channels. Their key insight is that progress requires not only local typing but also a global ordering condition on channel usage. Coppo, Dezani-Ciancaglini, Padovani, and Yoshida [Coppo et al., 2013] subsequently show that this ordering can be *inferred* rather than annotated, using a constraint-based analysis.

ICE-UTxO faces a structurally analogous problem: multiple protocol instances may share UTxO outputs, creating potential deadlocks at the ledger level. Our solution is to encode the global ordering directly in the *event-structure causal order* (Section 3) and to enforce it via S-BAC lock acquisition (Section 6). The key difference is that in our setting the "channels" are UTxO cells whose consumption is *atomic and irrevocable*, which simplifies the progress argument but introduces the need for cross-shard coordination that classical MPST avoids.

### Beyond Duality

Scalas and Yoshida [Scalas and Yoshida, 2019] generalise binary session types beyond syntactic duality using a *rely/guarantee* formulation inspired by concurrent separation logic. Their framework allows one endpoint's type to be verified independently under assumptions about the other's behaviour, enabling modular reasoning about open systems. ICE-UTxO draws on this philosophy when it decomposes a global protocol into per-validator proof obligations (Section 4): each validator's correctness proof *relies* on the structural guarantees of the UTxO model (uniqueness of consumption) and *guarantees* local adherence to the projected session type. Our setting is inherently multiparty, however, so the rely/guarantee decomposition is driven by projection from a global type rather than by binary co-typing.

### Event-Structure Semantics

Castellani, Dezani-Ciancaglini, and Giannini [Castellani et al., 2024] develop an *event-structure semantics* for asynchronous multiparty session types, replacing the traditional operational semantics based on labelled transition systems with a denotational model in which communication actions are events related by causality and conflict. This is the single most closely related work to ours. Their event structures capture the true concurrency inherent in asynchronous multiparty interaction, avoiding the artificial interleaving that LTS-based semantics impose.

ICE-UTxO builds directly on this line of work. Our *transaction event structures* (Section 3) instantiate the Castellani--Dezani-Ciancaglini--Giannini framework in a blockchain setting: events are ledger transitions (transaction submissions), causality is the UTxO spend relation, and conflict arises when two transactions attempt to consume the same output. We extend their model in three ways. First, we add *algebraic effects* to events, allowing each transaction to carry computational side-effects (e.g., coroutine suspension and resumption) that are interpreted by the ledger runtime. Second, we annotate events with *proof witnesses*, transforming the event structure from a semantic domain into a *proof-carrying* artefact that the ledger can verify. Third, we provide a *mechanised* (Lean 4) equivalence proof between the event-structure semantics and the operational semantics of our extended UTxO ledger, whereas Castellani et al.'s results are paper-based.

### Monitoring and Hybrid Verification

Bocchi, Chen, Denielou, Honda, and Yoshida [Bocchi et al., 2017] introduce *monitors* derived from multiparty session types for verifying communication at runtime. Monitors are finite-state automata generated from projected local types that observe messages as they pass through a communication medium, raising alarms on protocol violations. Neykova, Bocchi, and Yoshida [Neykova et al., 2017] extend this approach to *timed* multiparty sessions, where monitors enforce both ordering and deadline constraints on messages.

ICE-UTxO adopts a conceptually similar runtime-verification architecture, but the "monitor" is the ledger's transaction-validation logic itself. Each transaction carries a proof witness that is checked by the validator script before the transaction is admitted to the chain. This design has two advantages over the classical monitoring approach: (i) invalid transitions are *rejected* rather than merely flagged, providing enforcement rather than detection; and (ii) the monitor's correctness is itself mechanically verified (our Lean 4 development proves that the validator accepts exactly the transitions permitted by the projected local type).

Hu and Yoshida [Hu and Yoshida, 2016] propose *hybrid session verification*, combining static typing of the protocol skeleton with runtime checking of data-dependent branching. Their system generates endpoint APIs from Scribble protocol descriptions, ensuring that the communication structure is type-safe while leaving payload validation to runtime checks. ICE-UTxO follows a broadly similar hybrid strategy: the *structural* properties of the protocol (ordering, participation, branching topology) are verified statically by our Lean 4 metatheory, while *payload* properties (datum validity, value conservation) are checked dynamically by on-chain validators using proof-carrying witnesses.

### Tooling and Code Generation

The *Scribble* protocol description language [Yoshida et al., 2014] provides a practical surface syntax for global types and has been adopted across several MPST toolchains. *NuScr* [Zhou et al., 2020] extends Scribble with a CFSM-based backend that supports automated protocol validation and endpoint code generation. ICE-UTxO's protocol description layer (Section 3) is inspired by Scribble's design but targets a different backend: instead of generating communicating finite-state machines, our compiler produces *Plutus validator scripts* annotated with proof obligations.

Voinea, Dardha, and Gay [Voinea et al., 2020] present *StMungo*, a tool that translates Scribble protocols into *typestate* specifications for Java, enforcing session discipline through object-oriented type systems. King, Ng, and Yoshida [King et al., 2019] apply MPST to web development, using static linearity checking to prevent protocol violations in browser-server interactions. Miu, Ferreira, Yoshida, and Zhou [Miu et al., 2020; Miu et al., 2021] extend this line to TypeScript, generating WebSocket-based communication code from Scribble protocols with full type safety.

These tools demonstrate the practical viability of MPST-based code generation across language ecosystems. ICE-UTxO contributes to this tradition by targeting *blockchain validator scripts* as the generated artefact---a domain where code-generation correctness is especially critical because deployed validators cannot be patched and govern the movement of real assets. Unlike StMungo or the TypeScript generators, our generated code carries *machine-checkable proofs* of protocol conformance, reflecting the higher assurance requirements of the ledger setting.

### Adaptation and Replication

Harvey, Fowler, Lindley, and Gay [Harvey et al., 2021] introduce *connection actions* that allow multiparty sessions to adapt at runtime by adding or removing participants. Their system extends MPST with explicit join and leave operations, preserving type safety across dynamic reconfiguration. ICE-UTxO supports a limited form of adaptation through its *coroutine suspension* mechanism (Section 3): a protocol participant may suspend, allowing another party to resume the coroutine in a later transaction. However, we do not currently support arbitrary participant addition or removal; extending our framework with Harvey et al.'s connection actions is an interesting direction for future work.

Le Brun, Fowler, and Dardha [Le Brun et al., 2025] extend MPST with *replication* (the "bang" operator from the pi-calculus), enabling protocols that spawn unboundedly many sub-sessions. This is relevant to ICE-UTxO because blockchain protocols often involve unbounded repetition---for instance, a payment channel that processes arbitrarily many off-chain updates before settling on-chain. Our current formalisation handles bounded unfolding of recursive types; incorporating Le Brun et al.'s replication would allow us to model genuinely unbounded protocol families.

Tirore, Bengtson, and Carbone [Tirore et al., 2025] provide the first *mechanised* proof of subject reduction for multiparty session types, formalised in Coq. Their work addresses a longstanding gap in the MPST literature, where metatheoretic results have traditionally been proved only on paper. ICE-UTxO shares this commitment to mechanised metatheory but targets a different set of properties: rather than subject reduction for a process calculus, we mechanise *ledger-level safety and progress* for an extended UTxO model. Our formalisation is carried out in Lean 4 rather than Coq, and is constructive throughout with zero uses of sorry or unverified axioms. We view our work and Tirore et al.'s as complementary: their mechanised subject reduction could serve as a certified front-end that feeds into our ledger-level back-end.

---

## 8.2 UTxO Models and Blockchain Verification

The *unspent transaction output* (UTxO) model was introduced with Bitcoin [Nakamoto, 2008], where each transaction consumes a set of outputs produced by previous transactions and creates new ones. Bitcoin's scripting language is intentionally limited, supporting only simple predicate checks (e.g., signature verification). This simplicity makes Bitcoin transactions easy to validate in parallel---a property that ICE-UTxO inherits and exploits---but precludes the expression of complex multi-step protocols within the scripting layer itself.

Chakravarty, Chapman, MacKenzie, Melkonian, Mueller, Peyton Jones, and Thompson [Chakravarty et al., 2020] introduce the *extended UTxO* (eUTxO) model that underlies Cardano. eUTxO enriches Bitcoin's UTxO model with *datums* (state attached to outputs) and *validator scripts* (arbitrary programs that guard output consumption). The authors provide a small-step operational semantics for eUTxO and prove basic safety properties (value conservation, no double spending). ICE-UTxO extends eUTxO in three directions: (i) we add *coroutine state* to datums, enabling multi-step protocols to be encoded as suspended computations that resume across transactions; (ii) we introduce *algebraic effects* into the validator execution model, allowing validators to perform structured side-effects (yield, resume, emit) that are interpreted by the ledger runtime; and (iii) we require each transaction to carry a *proof witness* demonstrating conformance to a projected session type, transforming validators from mere predicates into proof checkers.

The *Agda formalisation* of UTxO ledger rules by Melkonian, Swierstra, and others [Melkonian et al., 2019] provides a mechanically verified reference semantics for the Cardano ledger. Their development covers the core UTxO transition rules and several ledger-level invariants. ICE-UTxO's Lean 4 formalisation covers analogous ground but extends the model with session-type indexing and proof-carrying transactions, and additionally proves the correspondence between event-structure and operational semantics---a result not addressed in the Agda development.

Sui's *Move* language [Blackshear et al., 2022] adopts an *object-centric* model that shares structural similarities with eUTxO: objects are analogous to UTxO outputs, and *programmable transaction blocks* (PTBs) allow multiple object operations to be composed atomically within a single transaction. Move's linear type system ensures that objects cannot be duplicated or discarded, providing resource-safety guarantees at the language level. ICE-UTxO differs from Move in its verification strategy: where Move relies on a bytecode verifier and linear type system to enforce resource safety, we employ multiparty session types to enforce *protocol-level* safety---ensuring not only that individual resources are used correctly but that the overall multi-party interaction adheres to a choreographic specification. The two approaches are potentially complementary, and integrating session-type discipline into a Move-like language is an intriguing avenue for future work.

---

## 8.3 Sharded Consensus

Al-Bassam, Sonnino, Bano, Hrycyszyn, and Danezis [Al-Bassam et al., 2018] introduce *Chainspace*, a sharded smart-contract platform that uses *Sharded Byzantine Atomic Commit* (S-BAC) to execute transactions spanning multiple shards. S-BAC decomposes cross-shard transactions into per-shard sub-transactions that are individually validated and then atomically committed or aborted via a two-phase protocol run across shard committees. ICE-UTxO adopts S-BAC as its cross-shard coordination primitive (Section 6) but adds a layer of protocol-level verification that Chainspace lacks: each sub-transaction carries a proof witness derived from the MPST projection, and the atomic-commit decision incorporates witness validation alongside the usual safety checks. This means that ICE-UTxO's cross-shard transactions are guaranteed to respect not only ledger-level invariants (no double spending, value conservation) but also application-level protocol structure (session fidelity, progress).

Classical distributed-systems literature offers several atomic-commit protocols relevant to our setting. The *two-phase commit* (2PC) protocol [Gray, 1978] provides atomicity but is blocking: if the coordinator fails after sending prepare messages, participants may be unable to make progress. *Three-phase commit* (3PC) [Skeen, 1981] eliminates the blocking window under a crash-failure model but does not tolerate Byzantine faults. *Atomix* and related BFT atomic-commit protocols [Kokoris-Kogias et al., 2018] extend atomic commit to adversarial settings, as does S-BAC.

ICE-UTxO's use of S-BAC follows the BFT atomic-commit line, but our contribution is orthogonal to the choice of commit protocol: we show how to *layer session-type verification on top of any atomic-commit primitive*, so that the commit decision reflects protocol-level correctness in addition to data-level consistency. In principle, our proof-carrying transaction architecture could be instantiated over 2PC, 3PC, or any other atomic-commit protocol, though the fault-tolerance guarantees would vary accordingly.

---

## 8.4 Mechanized Proofs of Concurrent Systems

*IronFleet* [Hawblitzel, Howell, Kapritsos, Lorch, Parno, Roberts, Setty, and Zill, 2015] demonstrates end-to-end verification of practical distributed systems in Dafny, covering both a Paxos-based replicated state machine and a sharded key-value store. IronFleet's methodology decomposes verification into a *protocol layer* (modelled as a state machine and verified for safety and liveness) and an *implementation layer* (verified to faithfully implement the protocol). ICE-UTxO adopts a similar two-layer decomposition---our event-structure semantics serves as the protocol layer, and the UTxO operational semantics serves as the implementation layer---but differs in two respects. First, our protocol layer is derived from multiparty session types rather than hand-written state machines, providing a more structured and compositional specification language. Second, our mechanisation targets Lean 4 rather than Dafny, enabling us to exploit dependent types and the Calculus of Inductive Constructions for proof terms that are themselves first-class data---a property we exploit when embedding proof witnesses into transactions.

*Verdi* [Wilcox, Woos, Panchekha, Tatlock, and Anderson, 2015] provides a Coq framework for implementing and verifying distributed systems using *verified system transformers*. A verified system transformer takes a system proven correct under one fault model and produces a system correct under a strictly stronger fault model---for example, transforming a system verified under a reliable-network assumption into one that tolerates network partitions. This compositional approach to fault tolerance is appealing, and ICE-UTxO's architecture exhibits a loose analogue: our event-structure metatheory is proven under an idealised model (no Byzantine faults, atomic ledger transitions), and the S-BAC layer provides the "transformer" that lifts these guarantees to a Byzantine fault-tolerant setting. However, we do not yet formally verify the S-BAC layer itself; doing so using Verdi-style transformers is a natural direction for future work.

*Aneris* [Krogh-Jespersen, Timany, Ohlenbusch, Gregersen, and Birkedal, 2020] builds on the Iris separation-logic framework in Coq to provide a program logic for reasoning about distributed systems that combine both local concurrent and network-level behaviour. Aneris supports node-local fine-grained concurrency via Iris's invariants and ghost state, while modelling network communication through a dedicated socket API with an associated protocol logic. ICE-UTxO's verification needs differ from Aneris's sweet spot: our system's concurrency is mediated entirely by the ledger (UTxO consumption is the sole synchronisation primitive), so we do not require Iris's fine-grained local-concurrency reasoning. On the other hand, Aneris's protocol logic for network communication could complement our work if extended to model ledger-mediated interaction, and its support for compositional invariants could help verify the S-BAC coordinator logic that we currently leave as a trusted component.

Across all three systems---IronFleet, Verdi, and Aneris---the verification target is a *general-purpose* distributed system. ICE-UTxO exploits the specific structure of UTxO ledgers (unique consumption, deterministic validation, immutable history) to obtain a simpler and more automated proof strategy. Our Lean 4 development completes with zero uses of sorry or unverified axioms, and the entire metatheory---covering session fidelity, progress, and the event-structure/operational-semantics correspondence---is constructive, meaning that proof witnesses can be extracted and embedded in transactions as first-class data. This *proof-carrying* property is the central novelty of ICE-UTxO relative to the mechanised-verification literature: rather than verifying a system implementation once and trusting it thereafter, we verify each individual protocol step at the moment it is submitted to the ledger.
