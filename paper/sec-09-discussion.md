# 9. Discussion and Future Work

The ICE-UTxO model and its Lean mechanization establish a formal foundation for proof-carrying transactions with multiparty coordination. Several important directions remain open.

**Full language semantics.** The current formalization captures the *ledger-level footprint* of coroutines and effects --- frame state, yield/resume events, effect raise/handle events --- but does not formalize the *computational semantics* of the coroutine programs themselves. A full language semantics would define the operational behavior of coroutine bodies (instruction execution, stack management, yield points) and prove that well-typed programs produce effects consistent with their coordination scripts. This would close the gap between the protocol-level model and the execution-level reality.

**IVC circuit soundness.** The predicate `allProofsVerified` is an oracle: it checks phase flags set by an external ZK verifier, but the formalization does not prove that the ZK verification algorithm is sound. A complete end-to-end proof would require mechanizing the ZK arithmetization (e.g., PLONK/Halo2) and proving a linkage theorem: the circuit constraints imply the protocol predicates checked by the ledger. This is a substantial undertaking that requires integrating formal methods for both interactive proofs and programming language semantics.

**Liveness and progress.** Section 4.6 establishes conditional liveness properties under explicit fairness assumptions: eventual commit under stability (Theorem 4.6), eventual terminalization (Theorem 4.7), and effect-handling progress (Theorem 4.8). The supporting lemmas are mechanized in Lean 4; the liveness theorems are paper-level arguments grounded in these lemmas and validated by TLC model checking under the corresponding fairness conditions. Full mechanization of temporal liveness in Lean 4 --- requiring either coinductive trace reasoning or a temporal logic embedding --- remains future work. Similarly, cross-shard liveness (L5) depends on BFT consensus guarantees outside the ledger model's scope.

**Computational extraction.** All predicates in the formalization are `Prop`-valued, not `Bool`-valued. While this is standard for specification-level formalization, it prevents direct computational execution within Lean (e.g., via `#eval`). Adding `Bool`-valued versions of key predicates (`allProofsVerifiedBool`, `conflictsBool`, `isAcyclicBool`) with proven equivalence to their `Prop` counterparts would enable executable validators and property-based testing within the Lean environment.

**Resource accounting.** The formalization does not model gas, compute budgets, or memory limits. In a deployment, each step (especially `raiseE`, `installH`, and `handleE`) would consume metered resources, and transactions exceeding their budget would abort. The effect queue and handler stack are unbounded in the formal model; a production system would impose per-transaction caps (e.g., maximum effect queue depth, maximum handler stack depth, maximum number of coroutine yields). Adding a gas or resource parameter to the `Step` relation --- e.g., $\mathit{Step} : \mathit{Mode} \to \mathbb{N} \to \mathit{Ledger} \to \mathit{Ledger} \to \text{Prop}$ with a fuel argument decremented at each step --- would formalize resource exhaustion as an abort condition without affecting the existing safety theorems.

**Real-world integration.** Connecting ICE-UTxO to actual eUTxO implementations (Cardano's Plutus, or a Sui-style PTB runtime) requires bridging the gap between the idealized model and concrete blockchain constraints: gas limits, transaction size bounds, serialization formats, and network protocols. The S-BAC integration is specified logically but not at the network protocol level.

**Phase transition enforcement.** The `ProofPhase` and `TxPhase` state machines are defined as inductive types with valid transition relations, but the `Step` constructors do not enforce that phase transitions follow these relations. A transaction could, in principle, have its proof phase set to `Verified` without going through `Generating` and `Verifying`. This is documented as a trust boundary (the external verifier enforces it), but tightening the formalization to enforce phase transitions in the step relation would strengthen the guarantees.

**Type-safe identifiers.** All identifier types (`UTXOId`, `TxId`, `InterfaceId`, `ProcessId`, `CommitmentHash`) are aliases for `Nat`. This means the type checker cannot catch errors where, say, a `UTXOId` is passed where a `TxId` is expected. Replacing these with wrapper structures (e.g., `structure UTXOId where val : Nat`) would add compile-time type safety at the cost of additional coercions in the proof development.

**Conflict-downward closure.** The current well-formedness rules for scripts do not enforce that conflict is *hereditary* (downward-closed under causality), as required by Winskel's original event structures. The formalization checks symmetry and irreflexivity but not $e \mathbin{\#} f \wedge e' < e \implies e' \mathbin{\#} f$. Adding this constraint would bring the model into full alignment with the event-structure literature and may enable additional metatheoretic results.

**Scaling the formalization.** At about 4,500 lines, the formalization is manageable but would benefit from closer integration with Mathlib. Several hand-proved lemmas duplicate existing Mathlib results, and the broad `import Mathlib` could be replaced with targeted imports to reduce compile times and make dependencies explicit.
